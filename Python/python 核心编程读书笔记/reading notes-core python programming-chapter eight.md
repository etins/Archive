---
title: Reading notes-core python programming-chapter eight
categories: tech
tags: python
---

## 第8章 条件和循环 ##


### 基础 ###

> pass

### 迭代器和iter()函数 ###

#### 什么是迭代器 ####

迭代器是版本2.2被加入Python的，它为类序列对象提供了一个类序列的接口。

#### 为什么要迭代器 ####

- 提供了可扩展的迭代器接口
- 对列表迭代带来了性能上的增强
- 在字典迭代中性能提升
- 创建真正的迭代接口，而不是原来的随机对象访问
- 与所有已经存在的用户定义的类以及扩展的模拟序列和映射的对象向后兼容
- 迭代非序列集合（例如映射和文件）时，可以创建更简洁可读的代码

#### 如何迭代 ####

根本上说，迭代器就是有一个next()方法的对象，而不是通过索引计数。当你或时一个循环机智需要下一个项时，调用迭代器的next()方法就可以获得它。条目全部取出后，会引发一个StopIteration异常，这并不标识表示错误发生，只是告诉外部调用者，迭代完成。

迭代器也有一些限制，不能向后移动，不能回到开始，也不能复制一个迭代器。

reversed()内建函数将返回一个反序访问的迭代器。enumerate()内建函数同样返回迭代器。any()和all()，如果迭代器中某个/所有条目的值都为布尔值，则返回值为真。

#### 使用迭代器 ####

    >>> myTuple = (123, 'xyz', 45.67)
	>>> i = iter(myTuple)
	>>> i.next()
	123
	>>> i.next()
	'xyz'
	>>> i.next()
	45.67
	>>> i.next()
	Traceback (most recent call last):
	  File "<stdin>", line 1, in <module>
	StopIteration

最佳实践

    fetch = iter(seq)
	while True:
		try:
			i = fetch.next()
		except StopInteration:
			break;
		do_something_to(i)
事实上for循环会自动调用迭代器的next()方法，对于字典和文件来说也是一样

#### 可变对象和迭代器 ####

除列表之外的其他序列都是不可变的。

在迭代可变对象时候修改他们并不好。一个序列的迭代器只是记录你当前到达多少个元素，所以如果你在迭代时改变了元素，更新会立即反映到你所迭代的条目上。

在迭代字典的键时，你绝对不能改变这个字典，使用字典的keys()方法是可以的，因为keys()返回一个独立于字典的列表。而迭代器是与世纪对象绑定在一起的，它将不会继续执行下去。

### 列表解析 ###

列表解析来自函数式编程Haskell。map()对所有的列表成员应用一个操作，filter()基于一个条件表达式过滤列表成员。最后，lambda允许你快速地创建只有一行的函数对象。

    [expr for iter_var in iterable]

	>>> map(lambda x: x ** 2, range(6))
	[0, 1, 4, 9, 16, 25]
	>>> [x ** 2 for x in range(6)]
	[0, 1, 4, 9, 16, 25]

### 生成器表达式 ###

生成器表达式于列表解析式非常相似，而且基本语法相同；不过生成器表达式并不真正创建数字列表，而是返回一个生成器，这个生成器每次计算出一个条目后，把这个条目产生（yield）出来。生成器表达式使用了延迟计算，所以它在使用内存上更有效。

	（expr for iter_var in iterable if cond_expr）







---EOF---

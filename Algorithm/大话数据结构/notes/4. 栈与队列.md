

队列是只允许在一段插入操作、在另一端进行删除的线性表。

### 4.2 栈的定义

栈是限定仅在表尾进行插入和删除操作的线性表。

允许哈如和删除的一端称为栈顶，另一端称为栈底，不含任何数据元素的栈称为空栈。栈又称为后进先出的线性表，简称 LIFO 结构。

### 4.3 栈的抽象数据类型

```
ADT 栈（stack）

Data
    同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。

Operation
    InsertStack(*S): 初始化操作，建立一个空栈S
    DestoryStack(*S): 若栈存在，则销毁它
    ClearStack(*S): 将栈清空
    StackEmpty(S): 若栈为空，返回 true， 否则返回 false。
    GetTop(S, *e): 若栈存在且为非空，用e返回S的栈定元素
    Push(S, *E): 若栈 S 存在，插入新元素 e 到栈 S 中并成为栈定元素
    Pop(*S, *e): 删除栈 S 中栈定元素，并用 e 返回其值
    StackLength(S): 返回栈 S 的元素个数
```

### 4.4 栈的顺序存储结构及实现

下表为 0 的一端作为栈底比较好，因为首元素存在于栈底，变化最小，所以让它作栈底。插入和删除就只需要移动栈定指针即可。

### 4.5 两栈共享空间

使用这样的数据结构，通常两个栈的空间需求有相反关系时，也就是一个栈增长，一个栈在缩短的情况。否则不要使用。

### 4.6 栈的链式存储结构及实现

栈的链式存储结构，简称链栈。

这样的情况下，是不需要头结点的。对于空栈来说，头指针就是空，就是 top=NULL。

如果栈的使用过程中元素变化不可预料，最好用栈链，反则用顺序链。

### 4.7 栈的作用

- 递归
- 逆波兰表示

### 4.10 队列的定义

队列是只允许在一端进行插入操作，在另一端进行删除操作的线性表。

### 4.11 队列的抽象数据类型

```
ADT 队列

Data

Operation
    InitQueue(*Q)
    DestoryQueue(*Q)
    ClearQueue(*Q)
    QueueEmpty(Q)
    GetHead(Q, *e)
    EnQueue(*Q, e)
    DeQueue(*Q, *e)
    QueueLength(Q)
```

### 4.12 循环队列

#### 4.12.1 队列顺序存储的不同

1. 数组下标为 0 的为队头，出队时，所有的元素就要向前移动，时间复杂度为 O(n)
2. 队头不一定为下标为 0， 那么出队时，对头的下标就要向后移动，此时队列容易发生假溢出

#### 4.12.2 循环队列的定义

我们把队列的这种头尾相接的存储结构称为循环队列。

循环队列就是通过控制对头和队尾的位置，相等时为空，差1时为满

当即便如此，循环队列也容易发生溢出的情况。

### 4.13 队列的链式存储结构及实现

队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已，简称为链队列。

### 4.14 总结回顾

循环队列必须有一个固定的长度，所以就有了存储元素个数和空间浪费的问题。而链队列不存在这个问题。
复用代码是 Java 众多引人注目的功能之一。但想要成为极具革命性的语言，仅仅能够赋值代码并对之加以改变还是不够的，它还必须能做更多的事情。

服用代码的方式：

1. 在新类中产生现有类的对象。由于新的类是由现有类的对象所组成的，所以这种方法称为组合。
2. 按照现有类的类型创建新类。无需改变现有类的形式，采用现有类的形式并在其中添加新代码。
3. 代理 继承和组合的中庸之道。

### 7.1 组合语法

初始化引用的方式：

1. 在定义对象的地方。
2. 在类的构造器中。
3. 就在正要使用这些对象之前。 惰性加载。
4. 使用实例初始化。


### 7.4 组合和继承

重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。

重写是子类对父类的允许访问的方法的实现过程进行重新编写！返回值和形参都不能改变。即外壳不变，核心重写！

### 7.5 在组合和继承之间选择

用一个“交通工具”来构成一部“车子”是毫无意义的，因为“车子”并不包含“交通工具”，它仅仅是一种交通工具（is-a关系）。“is-a”的关系是用继承来表达的，而“has-a”（有一个）的关系则是用组合来表达的。

### 7.7 向上转型

“为新的类提供方法”并不是继承技术中最重要的方面，其最重要的方面是用来表现新类和基类之间的关系。这种关系可以用“新类是现有类的一种类型”这句话加以概括。

参数类型为基类时，传入导出类对象引用依旧起作用，称之为向上转型。

#### 7.7.2 再论组合与继承

如果向上转型是必须的，则继承时必要的；但如果不需要，则应当好好考虑是不是需要继承。

### 7.8 final 关键字

根据上下文环境， Java的关键字final的含义存在着细微的区别，但通常它指的是“这是无法改变的”。不想改变可能处于两种理由：设计或效率。

#### 7.8.1 final 数据

1. 一个永不改变的编译时常量 减轻运行时负担
2. 一个在运行时被初始化的值 

一个即是 static 又是 final 的域只能占一段不能改变的存储空间。

当对对象引用而不是基本数据类型的final时，其含义会有一点令人迷惑。对于基本数据类型，final使数值恒定不变；而对于对象引用，final使引用恒定不变。一旦应用初始化执行的一个对象，就无法再把它改为指向另一个对象。

空白 final：即声明为 final但又未给定初始值的域。这样一个类中的 final 域可以根据对象不同，却又保持其恒定不变的特性。

final 参数，无法再方法中更改参数引用指向的对象。

#### 7.8.2 final 方法

1. 把方法锁定，以防任何继承类修改它的含义
2. 效率（只是 Java 早期）

final 和 private 关键字， 类中的 private 方法都隐式地指定为是 final 的。

#### 7.9.1 继承与初始化

编译器注意到它又一个基类，于是继续进行加载。基类中的 static 初始化即会执行，然后是下一个导出类，以此类推。

必要的类加载完成后，对象就可以被创建了。首先，对象中所有的基本类型都会设置为默认值，对象引用被设为 null。然后基类的构造器会被调用。基类构造器和导出类的构造器一样，以相同的顺序来经历相同的过程。在基类构造器完成之后，实例变量按其次序被初始化。最后，构造器的其余部分被执行。

1. 基类的静态成员与静态方法
2. 导出类的静态成员与静态方法
3. 基类的非静态成员
4. 基类构造器
5. 导出类的非静态成员
6. 导出类的构造器
7. 其余方法

### 7.10 总结

继承和组合都能从现有类型生成新类型。组合一般是将现有类型作为新类型底层实现的一部分加以复用，而继承复用的是接口。

在使用继承时，由于导出类具有基类接口，因此它可以向上转型至基类，这对多态来讲至关重要



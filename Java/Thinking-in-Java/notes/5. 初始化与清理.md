
随着计算机革命的发展，“不安全”的编程方式已逐渐成为编程代价高昂的原因之一。

### 5.1 用构造器确保初始化

Java 中采用和 C++ 一样的做法，构造器与类相同的名称。

构造器的目的就是确保初始化

### 5.2 方法重载

两个原因
1. 相同的词可以表达相同的含义
2. 为了让方法名相同而参数名不同构造器同时存在，必须用到方法重载 

#### 5.2.2 涉及基本类型的重载

如果传入的数据类型（实际参数类型）小于方法中声明的形式参数类型，实际数据类型就会被提升。char 略有不同，如果无法找到恰好接受 char 参数的方法，就会把 char 直接提升到 int 型。

如果传入的实际参数大，就得类型转换来执行窄转换。否则，就会报错。

### 5.4 this 关键字

1. 当你需要明确指出当前对象的引用时，才需要使用 this 关键字
2. 将当前对象传递给其他方法
3. 构造器中调用构造器，重用代码

#### 5.4.2 static 的含义

static 方法是没有 this 的方法，static 方法内部不能调用非静态方法；反过来可以。

### 5.5 清理：终结处理和垃圾回收

1. 对象可能不会被垃圾回收
2. 垃圾回收并不等于“析构” 
3. 垃圾回收只与内存有关

finalize() 使用场景
1. 消除非创建对象的方式为对象分配的存储空间。比如说调用 c 或者 c++ 代码，在此方法中可以调用 free() 函数。
2. 对象终结条件的验证

#### 5.5.4 垃圾回收器如何工作

引用计数：每个对象有一个引用计数器，当有引用连接至对象的时，引用计数加1.当引用离开作用域或被置为 null 时，引用计数器减 1.垃圾回收器会在含有全部对象的引用上遍历，当发现某个对象的引用计数为0时，就释放其占用的空间。缺陷：当存在循环引用的时候，就会出现对象应该被回收，但引用计数并不为0。

一些更快的模式: 对任何“活”的对象，一定能追溯到其在堆栈或静态存储区之外的引用。由此，如果从堆栈或静态存储区开始，遍历所有的引用，就能找到所有“活”的对象。对于发现的每个引用，必须追踪它引用的对象，然后是此对象包含的引用，反复如此，直到“根据源于堆栈和静态存储区的引用”所形成的网络全部被访问为止。所访问的对象都是“活”的，解决了“交互自引用的对象组”。

至于 Java 的垃圾回收，关于文中所讲述的关于 块 的部分不理解，后续继续理解。

### 5.7 构造器初始化

在类中，先初始化成员变量，再调用构造函数。确保成员变量的初始化。

#### 5.7.2 静态数据的初始化

1. 初始化静态成员，只会被初始化一次
2. 初始化非静态成员  
3. 执行构造函数

### 5.8 数组初始化

拥有的是对数组的一个引用，```int[] a1```

对于数组越界问题，Java 会抛出异常，而 C 和 C++会允许你访问所有的内存。但是每次访问数组都要检查边界的做法在时间和代码上是需要开销的，这意味着如果数组访问发生在一些关键点上，它们可能会是导致程序效率低下的原因之一。但 Java 的设计者认为这种权衡是值得的。

#### 5.8.1 可变参数列表

不需要再现实地编写数组语法了，指定参数时，编译器实际上会为你去填充数组

```
static void printArray(Object[] args) {
    for (Object obj : args)
        System.out.println(obj + " ");
}

static void printArray(Object... args) {
    for (Object obj : args) 
        System.out.println(obj + " ");
}
```

### Question

书 105 页，已标记。

再次看了好久，也想不明白为何。那就牢记以下的这句话：你应该总是只在重载方法的一个版本上使用可变参数列表，或者压根不适用它。

### 3.2 线性表的定义

线性表：零个或多个数据元素的有限序列。

每个元素（除最后一个元素外）有且仅有一个直接后驱，每个元素（除第一个元素外）有且仅有一个直接前驱。

### 3.3 线性表的抽象数据类型

抽象数据类型定义：
```
ADT 线性表（List）
Data 对象集合，每个元素的类型均为 DataType。其中除第一个元素 a1 外，
每一个元素有且仅有一个直接前驱元素，除了最后一个元素外，每一个元素有
且只有一个直接后继元素。

Operation
    InitList(*L); 初始化操作，建立一个空的线性表L。
    ListEmpty(L); 若线性表为空，返回 true, 否则返回 false。
    CleareList(*L); 将线性表清空。
    GetElem(L, i, *e); 获取第 i 个元素的位置，返回给 e 。
    LocateElem(L, e); 查找与 e 相等的元素，如果查找成功，返回序号；否则返回 0。
    ListInsert(*L, i, e); 第 i 个位置插入新元素 e。
    ListDelete(*L, i, *e); 删除第 i 个位置的元素，并用 e 返回其值。
    ListLength(L); 返回线性表 L 的元素个数。

endADT
```

### 3.4 线性表的顺序存储结构

线性表的顺序存储结构，指的是用一段地址连续的存储单元以此存储线性表的元素。

###  3.5 顺序存储结构的插入和删除

#### 3.5.4 线性表顺序存储结构额优缺点

优点：
- 无须为表示表中元素之间的逻辑关系而增加额外的存储空间
- 可以快速的存取表中任一位置的元素

缺点：
- 插入和删除操作需要移动大量元素
- 当线性表长度变化较大时，难以确定存储空间的容量
- 造成存储空间的“碎片”

### 3.6 线性表的链式存储结构

为了表示每个数据元素 a(i) 与 其后继元素 a(i+1) 之间的逻辑关系，对数据元素 a(i) 来说，除了存储本身的信息之外，还需要存储一个指示其直接后继的信息。我们把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息被称作指针或链。这两部分信息组成数据元素 a(i) 的存储印象，称为结点(Node)。

n 个结点链结成一个链表，即为线性表的链式存储结构，因为此链表的每个结点只包含一个指针域，所以叫做单链表。

链表中第一个结点的存储位置叫做头指针。

为了方便地对链表操作，会在单链表的第一个节点前附设一个结点，称为头结点。

头指针
- 头指针是指链表指向第一个节点的指针，若链表有头结点，则是指向头结点的指针
- 头指针具有标识作用，所以常用头指针冠以链表的名字
- 无论链表是否为空，头指针均不为空。头指针是链表的必要元素。

头结点
- 头结点是为了操作的统一和方便而设立的，放在第一元素的结点之前，其数据域一般无意义。
- 有了头结点，对在第一元素结点前插入结点和删除第一结点，其操作与其它结点就统一了。
- 头结点不一定是链表的必须要素。

### 3.11 单链表与顺序存储结构优缺点

存储分配方式：

- 顺序存储结构用一段连续的存储单元依次存储线性表的数据元素
- 单链表采用链式的存储结构，用一组任意的存储单元放线性表的元素

时间性能：

- 查找：顺序表存储结构O(1), 单链表O(n)
- 插入和删除：顺序存储结构需要平均移动表长一般的元素，时间为O(n);单链表在线出某位置的指针后，插入和删除时为O(1)

空间性能：

- 顺序存储结构需要预分配存储空间，分大了浪费，分小了容易上溢
- 单链表不需要分配存储空间，只要有就可以分配，元素个数也不受限制

### 3.12 静态链表

用数组描述的链表叫做静态链表。

每一个数组元素都是由两个数据域组成，data 和 cur。也就是说，数组每个下标都对应一个 data 和 cur。数据域 data， 用来存放数据元素；而 curl 相当于单链表中的 next 指针，存放该元素的后继在数组的下标。

静态链表要解决的是：如何静态模拟动态链表结构的存储空间的分配，需要时申请，无用时释放。在静态链表中操作的是数组，不像在动态链表的结点申请和释放问题，因此要自己实现这两个函数，才可以做插入和删除的操作。

将所有未使用过的及已被删除的分量用游标链成一个备用的链表，每当进行插入时，便可以从备用链表取第一个结点作为带插入的新结点。

优点：
- 在插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了顺序存储结构中的插入和删除操作需要移动大量元素的缺点。

缺点
- 没有解决连续存储内存分配问题
- 失去了顺序存储结构随机存储的特性

### 3.13 循环链表

将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表。

循环链表解决了一个很麻烦的问题，如何从一个结点出发，访问到链表的全部节点。

### 3.14 双向链表

双向链表是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。所以再双向链表中的结点都有两个指针域，一个指向直接后继，另一个指向直接前驱。

值得注意的点，插入时：先搞定插入结点的前驱和后继，再搞定后结点的前驱，最后解决前结点的后继。删除时，将前结点后继指向后结点，后结点的前驱指向前结点，释放内存即可。

双向链表使得对某个结点的前后结点操作带来方便。其实就是用空间来换时间。
---
title: Reading notes-core python programming-chapter twelve
categories: tech
tags: python
---

## 第12章 模块 ##

### 12.1 什么时模块 ###

模块支持从逻辑上组织代码。当代码量大的时候，我们最好把代码分成一些有组织的代码段，前提时保证它们的彼此交互。把其它模块中的属性附加到你的模块中的操作叫做导入。那些自我包含并且有组织的代码片段就是模块。

### 12.2 模块和文件 ###

如果说模块是按照逻辑来组织Python代码的方法，那么文件便是物理层上组织模块的方法。因此一个文件被看作是一个独立的模块，一个模块也可以被看作是一个文件。

#### 12.2.1 模块名称空间 ####

一个名称空间就是一个从名称到对象的关系映射集合。我们知道模块名称是它们的属性名称中的一部分。例如string模块中的atoi()函数就是string.atoi()。给定一个模块名之后，只可能有一个模块被导入到Python解释器中，所以在不同模块间不会出现名称交叉现象，所以每个模块都定义个它自己唯一的名称空间。

#### 12.2.2 搜索路径和路径搜索 ####

模块的导入需要一个叫做路径搜索的过程。既在文件系统预定义区域中查找mymodule.py文件。这些预定义区域只不过是你的Python搜索路径的集合。路径搜索和搜索路径是两个不同的概念，前者是指查找某个文件的操作，后者是去查找一组目录。

解释器启动后可以访问这个搜索路径，它会被保存在sys模块的sys.path变量里，不过它已经不是冒号分隔的字符串，而是包含每个独立路径的列表。可以通过appen()方法添加。

    sys.path.append('/home/wesc/py/lib');

只要这个列表中的某个目录包含这个文件，它就会被正确的导入。当然，这个方法是把目录追加在搜索路径的尾部。如果你有特殊需要，那么应该使用insert()方法操作。

使用sys.modules可以找到当前导入了哪些模块和它们来自什么地方。和sys.path不同，sys.modules是一个字典，使用模块名作为键，对应的物理地址作为值。

### 12.3 名称空间 ###

名称空间是名称到对象的映射。向名称空间添加名称的操作过程设计绑定标识符到对象的额操作。改变一个名字的绑定叫做重新绑定，删除一个名字叫做解除绑定。

Python解释器首先会加载内建名称空间。它有builtins模块中的名字构成。随后加载执行模块的全局名称空间，它会在模块开始执行后变为活动名称空间。这样我们就有了两个活动的名称空间。如果在执行期间调用了一个函数，那么将创建出第三个名称空间，级局部名称空间。

#### 12.3.1 名称空间与变量作用于比较 ####

名称空间是纯粹意义上的名字和对象间的映射关系，而作用域还指出了从用户代码的那些物理位置可以访问到这些名字。

#### 12.3.2 名称查找，确定作用于，覆盖 ####

访问一个属性时，解释器必须在三个名称空间的一个找到它。首先从局部名称空间，如果没有找到，会继续从全局名称空间找，最后将在内建名称空间找。如果都没有，会报错。

### 12.4 导入模块 ###

    import Tkinter


### 12.5 导入模块 ###

    from cgi import FiledStorage
    import Tkinter as tk
    from cgi import FiledStorage as form

### 12.6 模块内建函数 ###

#### 12.6.1 __import__() ####

作为实际导入模块的函数，意味着import语句调用__import__()函数完成它的工作。

    sys = __import__('sys')

#### 12.6.2 gloabls()和locals() ####

globals()和locals()内建函数分别返回调用者全局和局部名称空间的字典。在一个函数内部，局部名称空间代表在函数执行时候定义的所有名字，locals()函数返回的就是包含这些名字的字典。globals()会返回函数可访问的全局名字

#### 12.6.3 reload() ####

    reload(module)

### 12.7 包 ####

包是一个有层次的文件目录结构，它定义了一个由模块和子包组成的Python应用程序执行环境。

- 为平坦的名称空间加入由层次的组织结构
- 允许程序员把有联系的模块组织在一起
- 允许分发这使用目录结构而不是一大堆混乱的文件
- 帮助解决有冲突的模块名称





---EOF---

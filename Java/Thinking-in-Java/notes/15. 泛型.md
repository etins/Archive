
一般的类和方法，只能使用具体的类型：要么是基本类型，要么是自定义的类。如果要编写可以用于多种类型的代码，这种刻板的限制队代码的束缚就会很大。

泛型在编程语言中出现时，其最初的目的是希望类或方法能够具备广泛的表达能力。如何做到这一点呢，正是通过结构类或方法与所使用类型之间的约束。

### 15.2 简单泛型

泛型的主要目的之一就是指定容器要持有什么类型的对象，而且由编译器来保证类型的正确性。
```
public class Holder<T> {
    private T a;
    public Holder3(T a) { this.a = a; }
    public T get() { return a; }
}
```

#### 15.2.1 一个元祖类库

return语句只允许返回单个对象，要想能返回多个对象，就要船舰一个对象，用它来持有想要返回的多个对象。使用泛型可以一次性的解决该问题，同时可以在编译器就能确保类型安全。

这个概念称为元组，它是将一组对象直接打包存储与其中的一个单一对象。这个容器对象允许读取其中元素，但是不允许向其中存新的对象。

### 15.3 泛型接口

泛型可以应用于接口，例如生成器，这是一种专门负责创建对象的类。

一般而言，一个生成器只定义一个方法，该方法用以产生新的对象。在这里就是 next() 方法。
```
public interface Generator<T> { T next(); }
```

### 15.4 泛型方法

```
public <T> void f(T x) {
    System.out.println(x.getClass().getName());
}
```

当使用泛型类时，必须在创建对象的时候指定类型参数的值，而使用泛型方法的时候，通常不必指明参数类型，因为编译器会为我们找出具体的类型。这称为类型参数推断。

#### 15.4.1 杠杆利用类型参数推断

类型推断只对赋值操作有效，其它时候并不起作用。如果你将一个泛型方法调用的结构作为参数，传递给另一个方法，这时编译器并不会执行类型推断，

在泛型方法中，可以显示地指明类型。

### 15.5 匿名内部类

泛型还可以应用于内部类以及匿名内部类。

### 15.6 构建复杂模型

泛型的一个重要好处是能够简单而安全地创建复杂的模型。

### 15.7 擦除的神秘之处

在泛型内部，无法获得任何有关泛型参数类型的信息。

Java 泛型是使用擦除实现的，这意味着当你使用泛型时，任何具体的类型信息都被擦除了，你唯一直到的就是你在使用一个对象。因此List<String>和List<Integer>在运行时事实上是相同的类型。这两种形式都被擦除为它们的原生类型，即List。

#### 15.7.3 擦除的问题

擦除主要的正当理由是从非泛型化代码到泛型化代码的转变过程，以及在不破坏现有类库的情况下，将泛型融入 Java 语言。

擦除的代码是显著的。泛型不能用于显式地引用运行时类型的操作之中，例如转型、instalceof操作和new表达式。因为所有关于参数的类型信息都丢失了。

当你希望将类型参数不要仅仅当作 object 处理时，就需要付出额外努力来管理边界。

### 15.7.4 边界处的动作

擦除在方法体中移除了类型信息，所以在运行时的问题就是边界：即进入和离开方法的地点。这些正式编译器在编译器执行类型检查并插入转型代码的地点。

泛型中的动作都发生在边界处--对传递进来的值进行额外的编译器检查，并插入对传递储区的值的转型。这有助于对擦除的混肴，记住，“边界就是发生动作的地方。”

### 15.8 擦除的补偿

正如我们看到的，擦除丢失了在泛型代码中执行某些操作的能力。任何在运行时需要知道确切类型信息的操作都将无法工作。偶尔可以绕过这些问题来编程，但有时必须通过引入类型标签来擦除进行补偿。这意味着你需要显示地传递你的类型 Class 对象，以便你可以在类型表达式中使用它。

### 15.9 边界

本章前面简单介绍过边界。边界使得你可以在用于发型的参数类型上设置限制条件。尽管这使得你可以强制规定泛型可以应用的类型，但是其潜在的一个更重要的效果是你可以按照自己的边界来调用方法。

因为擦除移除了类型信息，所以，可以用无界泛型参数调用的方法只是哪些可以用 object 调用的方法。但是，如果能够将这个参数限制为某个类型子集，那么你就可以用这些类型子集来调用方法。

通配符被限制为单一边界。

### 15.10 通配符

泛型的主要目的之一是将这种错误检测移入到编译期。

### 15.11 问题

1. 任何基本类型都不能作为类型参数
2. 实现参数化接口
3. 转型和警告
4. 重载
5. 基类劫持了接口

### 15.12 自限定的类型

### 15.13 动态类型安全

### 15.14 异常

### 15.15 混型

### 15.16 潜在类型机制

### 15.17 对缺乏潜在类型机制的补偿

### 15.18 将函数对象用作策略

### 15.19 总结：转型真的如此之糟吗？

使用泛型类型机制的最吸引人的地方，就是在使用容器类的地方，这些类包括各种 List， 各种 Map等。当你将一个对象放置在容器中时，这个对象就会向上转型为 object，因此你会丢失类型信息。当你想要将这个对象从容器取回，用它取执行某些操作时，必须将其向下转型回正确的类型。
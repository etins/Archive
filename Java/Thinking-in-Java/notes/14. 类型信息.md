RTTI（Run-Time Type Identification)，运行时类型信息使得你可以在程序运行时发现和使用类型信息。

### 14.1 为什么需要 RTTI

面向对象编程的基本目的是：让代码只操纵对基类的引用。

所有的类型转换都是在运行时进行正确检查的，这也是 RTTI 名字的含义：在运行时，识别一个对象的类型。

在编译时，将由容器和 Java 的泛型系统来强制确保这一点；而在运行时，由类型转换操作来确保这一点。然后就是多态的事情了，基类对象实际执行什么代码，是由引用所指向的具体对象而决定的。通常，也正是这样要求的；你希望大部分代码尽可能少地了解对象的具体类型，而只与对象家族中的一个通用表示打交道。这样代码会更容易写，更容易读，且便于维护；设计也更容易实现、理解和改变。所以“多态”是面向对象编程的基本目标。

但是如果你碰到了一个特殊的编程问题--如果能够知道某个泛化引用的确切类型，就可以使用最简单的方式去解决它，此时就需要 RTTI 了。

### 14.2 Class 对象

类是程序的一部分，每个类都有一个 Class 对象。换言之，每当编写并且编译了一个新类，就会产生一个 Class 对象。为了生成这个类的对象，运行这个程序的 Java虚拟机 将使用“类加载器”的子系统。

类加载器子系统实际上可以包含一条类加载器链，但是只有一个原生类加载器，它是 JVM 实现的一部分。原生类加载器加载的是所谓的可信类，包括 Java API类，它们通常是从本地盘加载的。

所有的类都是在对其第一次使用时，动态加载到 JVM 中的。当程序创建第一个对类的静态成员引用时，就会加载这个类。这个证明构造器也是类的静态方法，即使构造器之前并没有使用 static 关键字。因此，使用 new 操作符创建类的新对象也会被当作对类的静态成员的引用。

Java 程序在它开始之前并非完全加载，其各个部分在必需时才加载的。

类加载器首先检查这个类的 class 对象是否已经加载。如果尚未加载，默认的类加载器就会根据类名查找 .class 文件。在这个类的字节码被加载时，它们会接受验证，以确保其没有被破坏，并且不包含不良 Java 代码。

一旦某个类的 Class 对象被载入内存，它就被用来创建这个类的所有对象。

#### 14.2.1 类字面常量

JAVA 还提供了另一种方法来生成对 Class 对象的引用，即使用字面常量。就是“.class”的形式。

当使用“.class”来创建对 Class 对象的引用时，不会自动地初始化该 Class 对象。为了使用类而做的准备工作包括三个步骤：
1. 加载，这是由类加载器执行的。
2. 链接，在链接结点将验证类中的字节码，为静态域分配存储空间，并且如果必需的话，将解析这个类创建的对其他类的所有引用。
3. 初始化，如果类具有超类，则对其初始化，执行静态初始化器和静态初始化快。

初始化有效地实现了尽可能的“惰性”。对 initable 引用创建中可以看到，仅使用 .class 语法来获得对类的引用不会引发初始化。

#### 14.2.2 泛化的 Class 引用

Class 引用总是指向某个 Class 对象，它可以制造类的实例，因此，Class 引用表示的就是它所指向的对象的确切类型，而该对象便是 Class 类的一个对象。

Class<?>,  Class<? extends Number>

向 Class 引用添加泛型语法的原因仅仅是为了提供编译类型检查，如果只是运行时才发现，会很不方便。

#### 14.2.3 新的转型语法

cast() 方法接受参数对象，并肩齐转型为 Class 引用的类型。

### 14.3 类型转换前先做检查

1. 传统的类型转换，由 RTTI 确保类型转换的正确性，如果执行了一个错误的类型转换，就会抛出 ClassCastException 异常。
2. 代表对象的类型的 Class 对象。通过查询 Class 对象可以获取运行时所需要的信息。
3. instanceOf,返回一个布尔值，告诉我们对象是不是某个特定类型的实例。

instaceof 有比较严格的限制：只可将其于命名类型进行比较，而不能与 Class 对象作比较。当程序中编写了许多的 instanceof 表达式，就说明在设计上可能存在瑕疵。

### 14.6 反射：运行时类信息

如果你不知道某个类的确切类型，RTTI可以告诉你。但是有一个限制：这个类型在编译时必须已知，这样才能使用 RTTI 识别。

1. 你获取了某个并不在你程序空间里的对象的引用。
2. 远程方法调用

反射机制并没有什么神奇之处。当你通过反射与一个未知类型的对象打交道时，JVM 只是简单检查这个对象，看它属于哪个特定的类（就像RTTI那样）。RTTI 和反射之间真正的区别只在于，对于 RTTI 来说，编译器在编译时打开和检查 .clss 文件。而对于反射机制， .class 文件在编译时是不可获取的，所以在运行时打开和检查 .clss 文件。

### 14.7 动态代理

代理是基本的设计模式之一，它是你为了提供额外的或不同的操作，而插入的用来代替实际对象的对象。

### 14.8 空对象

有时候引入空对象的思想会很有用，它可以接受传递给它的所代表的对象的消息，但是返回表示为实际上并不存在任何“真实”的值。

### 14.9  接口与类型信息

interface 关键字的一种重要目标就是允许程序员隔离构件，进而降低耦合性。如果编写接口，那么就可以实现这一目标。 

### 14.10 总结

RTTI 允许通过匿名内部类来发现类型信息。在使用多态调用方法之前，这么做很有效，面向对象编程语言的目的是让我们在凡是可以使用的地方都使用多态机制，只在必需的时候使用 RTTI。

使用多态机制的方法调用，要求我们拥有基类定义的控制权，因为在扩展程序的时候，可能会发现基类并未包含我们想要的方法。如果基类是别人的类，这时 RTTI 时一种解决之道：可以继承一个新类，然后添加你需要的方法。在代码的其它地方，可以检查你自己特定的类型，并调用你自己的方法。

RTTI 有时能解决效率问题。也许你的程序漂亮地运用了多态，但其中某个对象是以极端缺乏效率的方式达到这个目的的。可以挑出这个类，使用 RTTI，并且为其编写一段特别的代码以提高效率。

动态代码是将 Java 与其它诸如 C++ 这样的语言分来的重要工具之一。

这一章看得我很蒙圈，回顾的时候要再看一遍这一章。
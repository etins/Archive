可以将一个类的定义放在另一个类的内部，这就是内部类。

内部类是一种非常有用的特性，因为它允许你把一些逻辑相关的类组织在一起，并控制位于内部类的可视性。内部类与组合是完全不同的概念。


### 10.2 链接到外部类

内部类拥有其它外围类的所有元素的访问权

### 10.3 使用 .this 与 .new

如果需要生成对外部类对象的引用，可以使用外部类的名字后面紧跟圆点和 this。要想创建一个内部类对象，要用外部类的对象来创建该内部类的对象。

在拥有外部类对象之前是不可能创建内部类对象的。因为内部类对象会暗暗地连接到创建它的外部类对象上。

### 10.4 内部类和向上转型

内部类可以转型为其基类，尤其是在转型为一个接口的时候，内部类就有了用武之地。这也是因为内部类--某个接口的实现--能够完全不可见，并且不可用。

private 内部类给类的设计者提供了一种途径，通过这种方式可以完全阻止依赖于类型的编码，并且完全隐藏了实现的细节。

### 10.5 在方法和作用域中的内部类

可以在一个方法里面或者任意作用域定义内部类。
1. 实现某类型的接口，返回对其的引用
2. 解决一个问题，想要创建一个类来作为解决方案，但又不希望这个类是公共可用的。

### 10.6 匿名内部类

匿名内部类没有构造器，因为它根本没有名字。

### 10.7 嵌套类

如果不需要内部类对象与其外围对象之间有联系，那么可以将内部类声明为 static。这通常称为嵌套类。普通内部类对象隐式地保存了一个引用，指向创建它的外围类对象。当然内部类式 static 时，就意味着：
1. 要创建嵌套类的对象，并不需要其外围类的对象
2. 不能从嵌套类的对象中访问非静态的外围类对象

### 10.8 为什么要有内部类

一般说来，内部类继承自某个类或者实现某个接口，内部类的代码操作创建它的外围类的对象。所以可以认为内部类提供了某种进入外部类的窗口。

内部类最吸引人的原因是：

每个类都能够独立地继承自一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。

从这个角度看，内部类使得多重继承的解决方案的变得完整。接口解决了部分问题，而内部类有效地实现了“多重继承”。也就是内部类允许继承多个非接口类型（类或抽象类）。

#### 10.8.1 闭包与回调

闭包是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域。通过这个定义，可以看出内部类是面向对象的闭包，因为它不仅包含外部类对象的信息，还自动拥有一个指向此外部类的引用，在此作用域内，内部类有权操作所有的成员，包括 private 成员。

回调的价值在于其灵活性--可以在运行时动态地决定要调用什么方法。

### 10.9 内部类的继承

内部类是绑定在外部类的对象上的，继承的时候也真是够麻烦的，当然默认无惨的构造函数还好

### 10.10 内部类可以被覆盖吗

内部类和外部类是完全独立的实体，各自在自己的命名空间内。明确地继承某个内部类是可以覆盖的。

### 10.11 局部内部类

使用局部内部类而不是匿名内部的理由：
1. 我们需要一个已命名的构造器，或者需要重载构造器，而匿名内部类只能用于实例初始化。
2. 我们需要不止一该内部类的对象

### 10.12 内部类标识符

内部类的 .class 文件命名方式：外围类的名字，加上“$”，再加上内部类的名字。

如果内部类是匿名的，编译器会简单地产生一个数字作为其标识符。如果内部类是嵌套再别的类之中，只需要将它们的名字在其外围类的与“$”的后面。

### 10.13 总结

为什么要有内部类是值得思考的问题：

1. 实现“多重继承”
2. 闭包与回调
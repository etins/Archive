在面向对象的程序设计中，多态是继数据抽象和继承之后的第三种基本特征。

### 8.1 再论向上转型

把某个对象的引用视为对其基本类型的引用的做法被称作为向上转型-因为在继承树的画法中，基类是放置在上方的。

#### 8.1.1 忘记对象类型

如果我们只写一个简单的方法，它仅接受基类作为参数，而不是那些特殊的导出类。这样编码会更简单些，这也正是多态所允许的。

### 8.2 转机

但是在向上转型的情况下，编译器并不知道基类的引用是来自于哪一个导出类。

#### 8.2.1 方法调用的绑定

将一个方法调用一个方法主体关联起来被称作绑定。若在程序执行之前进行绑定（由编译器和链接程序实现），叫做前期绑定。由此让人迷惑。

解决的办法就是后期绑定，它的含义就是在运行时根据对象的类型进行绑定。后期绑定也叫做动态绑定或运行时绑定。如果一种语言实现后期绑定，就必须具有某种机制，以便运行时能判断对象的类型，从而调用恰当的方法。

Java 中除了 static 方法和 final 方法之外，其它所有的方法都是后期绑定。这意味着，我们不必判定是否应该进行后期绑定--它会自动发生。

最好根据设计来决定是否使用 final， 而不是出于试图提高性能的目的来使用 final。

#### 8.2.2 产生正确的行为

当我们跟基类的方法进行交互时，方法A只要传入基类的引用，此时我们传入导出类引用，如果导出类重载了该方法，那么将会自动执行该导出类的方法，否则执行基类的方法。

#### 8.2.3 可扩展性

只与基类接口通信，这样的程序是可扩展的。换句话来说多态是让程序员“将改变的事物与未变的事物分离开来”的重要技术。

#### 8.2.4 缺陷：“覆盖”私有方法

只有非 private 的方法才可以被覆盖。

#### 8.2.5 缺陷：域与静态方法

只有普通的方法调用是多态的。针对静态方法是无效的。因为静态方法是与类，而并非与单个的对象相关联。

### 8.3 构造器和多态

#### 8.3.2 继承与清理

销毁顺序应该和初始化顺序相反。

如果成员对象存在与其他一个或多个对象共享的情况，问题就复杂了，也就必须使用引用计数来跟踪仍旧访问着共享对象的对象数量了。

#### 8.3.3 构造器内部多态方法的行为

初始化的过程是：

0. 将分配给对象的存储空间初始化为二进制的零
1. 调用基类构造器
2. 按照声明顺序调用成员的初始化方法
3. 调用导出类构造器的主体


### 8.5 用继承进行设计

更好的方式是选择“组合”。

有时候也可以强制向下转型